local game = require("assets.scripts.game")

local function clamp (value, min, max)
	if value < min then return min
	elseif value > max then return max
	else return value
	end
end

local function handle_level_collisions(self, normal, distance)
	if distance > 0 then
		local extent = vmath.project(self.correction, distance * normal)
		if extent < 1 then
			local compensation = (distance - distance * extent) * normal
			go.set_position(go.get_position() + compensation)
			self.correction = self.correction + compensation
		end
	end
	if math.abs(normal.x) > 0 and math.abs(distance) > 0.1 then
		self.velocity.x = 0
	end
end

function init(self)
	msg.post("#", "acquire_input_focus")
	defos.set_cursor_visible(false)
	self.velocity = vmath.vector3(0, 0, 0)
	self.on_ground = 0
	self.pushing_ceiling = 0
	self.correction = vmath.vector3()
	self.speed = 150
	self.gravity = 10
	self.current_anim = ""
	self.near_box = nil
	self.holding = nil
	self.hold_pos = go.get_position("/go")
	self.mouse_pos = vmath.vector3(0)
	self.dir = 1
	self.blue_portal = nil
	self.orange_portal = nil
	self.mode = 1
end

function fixed_update(self, dt)
	self.velocity.y = self.velocity.y - self.gravity * dt
	self.velocity.y = clamp(self.velocity.y, -2000, 2000)
	if self.on_ground > 0 then
		self.velocity.y = math.max(0, self.velocity.y)
	end
	if self.pushing_ceiling > 0 then
		self.velocity.y = math.min(0, self.velocity.y)
	end
	local pos = go.get_position()
	pos = pos + self.velocity * self.speed * dt
	go.set_position(pos)

	local dir = self.mouse_pos - pos
	if dir.x > 0 then
		sprite.set_hflip("#sprite", false)
		physics.set_hflip("#co", false)
		physics.set_hflip("#reach", false)
		physics.set_hflip("#feet", false)
		physics.set_hflip("#head", false)
		go.set_position(self.hold_pos, "/go")
	elseif dir.x < 0 then
		sprite.set_hflip("#sprite", true)
		physics.set_hflip("#co", true)
		physics.set_hflip("#reach", true)
		physics.set_hflip("#feet", true)
		physics.set_hflip("#head", true)
		go.set_position((-1) * self.hold_pos, "/go")
	end
	self.correction.x = 0
	self.correction.y = 0
	self.velocity.x = 0
end

function on_input(self, action_id, action)
	local pos = go.get_position()
	if action_id == hash("right") then
		self.velocity.x = self.velocity.x + 1
	elseif action_id == hash("left") then
		self.velocity.x = self.velocity.x - 1
	elseif action_id == hash("jump") and action.pressed and self.on_ground > 0 then
		self.velocity.y = 3
		--self.current_anim = "jump"
		--sprite.play_flipbook("#sprite", hash("jump"))
	elseif action_id == hash("use") and action.pressed and self.near_box ~= nil and self.holding == nil then
		--go.set_parent(self.near_box, ".", true)
		self.holding = self.near_box
		msg.post(self.holding, "follow", { parent = "/go" })
	elseif action_id == hash("use") and action.pressed and self.holding ~= nil then
		msg.post(self.holding, "unfollow", { velocity = vmath.vector3(self.velocity.x * 1.5, self.velocity.y, 0) })
		self.holding = nil
	elseif action_id == hash("l_click") and action.pressed then
		game.tp = false
		if game.blue then
			go.delete(game.blue)
			game.blue = nil
		end
		game.blue = factory.create("/player#fac_blue", pos, nil, { velocity = vmath.normalize(self.mouse_pos - pos), color = 1}, vmath.vector3(1))
	elseif action_id == hash("r_click") and action.pressed then
		game.tp = false
		if game.orange then
			go.delete(game.orange)
			game.orange = nil
		end
		game.orange = factory.create("/player#fac_orange", pos, nil, { velocity = vmath.normalize(self.mouse_pos - pos), color = 2}, vmath.vector3(1))
	elseif action.screen_x ~= nil and action.screen_y ~= nil then
		self.mouse_pos = vmath.vector3(action.screen_x / window.get_display_scale(), action.screen_y / window.get_display_scale(), 0)
		go.set_position(vmath.vector3(self.mouse_pos.x, self.mouse_pos.y, 0.2), "/cursor")
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		if message.own_group == hash("feet") then
			if self.tp then self.tp = false end
			if message.enter then self.on_ground = self.on_ground + 1
			else self.on_ground = self.on_ground - 1 end
		elseif message.own_group == hash("head") then
			if message.enter then self.pushing_ceiling = self.pushing_ceiling + 1
			else self.pushing_ceiling = self.pushing_ceiling - 1 end
		end
		if message.other_group == hash("box") and message.enter and self.near_box == nil then
			self.near_box = message.other_id
			msg.post(self.near_box, "show_key")
		elseif message.other_group == hash("box") and not message.enter and self.near_box == message.other_id then
			msg.post(self.near_box, "hide_key")
			self.near_box = nil
		end
	elseif message_id == hash("contact_point_response") then
		handle_level_collisions(self, message.normal, message.distance)
	elseif message_id == hash("disable_co") then
		msg.post("#co", "disable")
	elseif message_id == hash("enable_co") then
		msg.post("#co", "enable")
	elseif message_id == hash("up") then
		self.velocity.y = 4
	elseif message_id == hash("down") then
		self.velocity.y = -1
	end	
end